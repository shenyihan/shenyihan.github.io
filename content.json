{"meta":{"title":"个人主页","subtitle":"Life doesn’t get easier，you just get stronger","description":"Life doesn’t get easier，you just get stronger","author":"杨向成","url":"https://shenyihan.github.io"},"pages":[{"title":"","date":"2017-12-29T04:39:32.176Z","updated":"2017-12-29T04:39:32.176Z","comments":false,"path":"tags/index.html","permalink":"https://shenyihan.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-12-29T04:39:02.000Z","updated":"2017-12-29T04:39:53.729Z","comments":false,"path":"categories/index.html","permalink":"https://shenyihan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"基于consul实现分布式锁","slug":"基于consul实现分布式锁","date":"2019-06-18T09:04:28.000Z","updated":"2019-06-18T09:20:48.886Z","comments":true,"path":"2019/06/18/基于consul实现分布式锁/","link":"","permalink":"https://shenyihan.github.io/2019/06/18/基于consul实现分布式锁/","excerpt":"","text":"基于consul实现分布式锁实现原理依托于consul的kv存储API中的acquire和release操作来实现，每个注册到consul的服务通过createsession方式获取sessionid 实现流程 流程图 实现代码三个类BaseLock.javaLock.javaTestLock.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import com.ecwid.consul.v1.ConsulClient;import com.ecwid.consul.v1.session.model.NewSession;import com.ecwid.consul.v1.session.model.Session;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.util.Timer;import java.util.TimerTask;@Data@Slf4jpublic class BaseLock &#123; protected ConsulClient consulClient; protected String sessionId = null; protected String keyPath; // 互斥锁、信号量存储在consul中的基础key路径 private Timer timer; // consul session 超时时间 private String sessionTTL = \"10s\"; // consul renew session定时任务第一次执行延迟时间 private long sessionTimerDelay = 5000L; // consul renew session定时任务每次执行时间间隔让consul知道此服务处于存活状态 private long sessionTimerPeriod = 3000L; /** * @param consulClient * @param lockKey 同步锁在consul的KV存储中的Key路径，会自动增加prefix前缀，方便归类查询 */ protected BaseLock(ConsulClient consulClient, String lockKey) &#123; this.consulClient = consulClient; this.keyPath = lockKey; &#125; /** * 创建session * @param sessionName * @return */ protected String createSession(String sessionName) &#123; NewSession newSession = new NewSession(); newSession.setName(sessionName); newSession.setBehavior(Session.Behavior.DELETE); newSession.setTtl(sessionTTL); this.sessionId = consulClient.sessionCreate(newSession, null).getValue(); timer = new Timer(); timer.scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; log.info(\"renew session, key path=&#123;&#125;\", keyPath); consulClient.renewSession(sessionId, null); &#125; &#125; , sessionTimerDelay, sessionTimerPeriod); return consulClient.sessionCreate(newSession, null).getValue(); &#125; /** * 根据成员变量sessionId来销毁session */ protected void destroySession() &#123; if (sessionId != null) &#123; cancelTimer(); consulClient.sessionDestroy(sessionId, null); sessionId = null; &#125; &#125; private void cancelTimer() &#123; /*if (EmptyUtil.isObjEmpty(timer)) &#123; return; &#125;*/ try &#123; timer.cancel(); &#125; catch (Exception e) &#123; log.error(\"cancel timer failed, keyPath=&#123;&#125;, message=&#123;&#125;\", keyPath, e.getMessage()); e.printStackTrace(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import com.ecwid.consul.v1.ConsulClient;import com.ecwid.consul.v1.kv.model.PutParams;import lombok.extern.slf4j.Slf4j;import java.time.LocalDateTime;/** * 基于Consul的互斥锁 * */@Slf4jpublic class Lock extends BaseLock &#123; private static final String prefix = \"lock/\"; // 同步锁参数前缀 /** * @param consulClient * @param lockKey 同步锁在consul的KV存储中的Key路径，会自动增加prefix前缀，方便归类查询 */ public Lock(ConsulClient consulClient, String lockKey) &#123; super(consulClient, prefix + lockKey); &#125; /** * 获取同步锁 * * @param block 是否阻塞，直到获取到锁为止，默认尝试间隔时间为500ms。 * @return */ public Boolean lock(boolean block) throws InterruptedException &#123; return lock(block, 500L, null); &#125; /** * 获取同步锁 * * @param block 是否阻塞，直到获取到锁为止 * @param timeInterval block=true时有效，再次尝试的间隔时间 * @param maxTimes block=true时有效，最大尝试次数 * @return */ public Boolean lock(boolean block, Long timeInterval, Integer maxTimes) throws InterruptedException &#123; if (sessionId != null) &#123; throw new RuntimeException(sessionId + \" - Already locked!\"); &#125; sessionId = createSession(\"lock-\" + this.keyPath); int count = 1; while(true) &#123; PutParams putParams = new PutParams(); putParams.setAcquireSession(sessionId); if(consulClient.setKVValue(keyPath, \"lock:\" + LocalDateTime.now(), putParams).getValue()) &#123; return true; &#125; else if(block) &#123; if(maxTimes != null &amp;&amp; count &gt;= maxTimes) &#123; return false; &#125; else &#123; count ++; if(timeInterval != null) Thread.sleep(timeInterval); continue; &#125; &#125; else &#123; return false; &#125; &#125; &#125; /** * 释放同步锁 * * @return */ public boolean unlock() &#123; boolean success = false; try &#123; success = executeUnlock(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; return success; &#125; private boolean executeUnlock() &#123; destroySession(); return true; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class TestLock &#123; @Test public void testLock() throws Exception &#123; ConsulClient consulClient = new ConsulClient(\"192.168.6.60\"); new Thread(new LockRunner(1)).start(); new Thread(new LockRunner(2)).start(); new Thread(new LockRunner(3)).start(); new Thread(new LockRunner(4)).start(); new Thread(new LockRunner(5)).start(); Thread.sleep(6000L); &#125;&#125;@Slf4j@AllArgsConstructorclass LockRunner implements Runnable &#123; private int flag; @Override public void run() &#123; Lock lock = new Lock(new ConsulClient(\"192.168.6.60\"), \"lock-key\"); try &#123; // 获取分布式互斥锁（参数含义：阻塞模式、每次尝试获取锁的间隔500ms、尝试n次） if (lock.lock(true, 500L, 10)) &#123; log.info(\"Thread &#123;&#125; start!\", flag); // 处理业务逻辑 Thread.sleep(new Random().nextInt(5000)); log.info(\"Thread &#123;&#125; end!\", flag); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;","categories":[],"tags":[]},{"title":"分布式事务","slug":"分布式事务","date":"2019-05-29T09:30:13.000Z","updated":"2019-05-30T01:20:59.070Z","comments":true,"path":"2019/05/29/分布式事务/","link":"","permalink":"https://shenyihan.github.io/2019/05/29/分布式事务/","excerpt":"","text":"分布式事务介绍 简单说下什么是分布式事务:分布式系统中一个请求请求多个服务时，要么同时成功要么同时失败。不能出现部分系统成功部分失败 分布式解决方案tx_lcn TX-LCN 主要有两个模块，Tx-Client(TC) Tx-Manager(TM). TC作为微服务下的依赖，TM是独立的服务。 官网：http://www.txlcn.org/zh-cn/index.html seata(目前不建议线上版本) 对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入 高性能：减少分布式事务解决方案所带来的性能消耗 说明：https://blog.csdn.net/hosaos/article/details/89136666","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"源码项目","slug":"源码项目","date":"2019-05-29T01:11:38.000Z","updated":"2019-05-29T09:01:36.222Z","comments":true,"path":"2019/05/29/源码项目/","link":"","permalink":"https://shenyihan.github.io/2019/05/29/源码项目/","excerpt":"","text":"管理后台eladmin 项目基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由 源码地址：https://github.com/elunez/eladmin 演示地址：https://auauz.net ruoyi 基于SpringBoot2.1的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。直接运行即可用 源码地址：https://github.com/lerry903/RuoYi 演示地址：http://ruoyi.vip/login 接口管理平台哆啦接口管理 支持多团队、多项目、多环境，带给你更多的方便，支持完整的权限管理，功能权限（菜单权限，节点权限）、数据权限（项目权限，分类权限） 官方地址：https://www.smaty.net/ 项目部署及配置：https://shuka.smaty.net/t/xapimanager (安装和升级请参考手册)","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://shenyihan.github.io/tags/源码/"}]},{"title":"实用工具","slug":"实用工具","date":"2019-05-29T01:11:38.000Z","updated":"2019-05-29T09:00:55.477Z","comments":true,"path":"2019/05/29/实用工具/","link":"","permalink":"https://shenyihan.github.io/2019/05/29/实用工具/","excerpt":"","text":"博客 https://funtl.com/","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"实用工具","slug":"实用工具","permalink":"https://shenyihan.github.io/tags/实用工具/"}]},{"title":"Spring-Boot自定义启动图案","slug":"Spring-Boot自定义启动图案","date":"2018-05-11T04:41:18.000Z","updated":"2018-05-25T09:38:58.007Z","comments":true,"path":"2018/05/11/Spring-Boot自定义启动图案/","link":"","permalink":"https://shenyihan.github.io/2018/05/11/Spring-Boot自定义启动图案/","excerpt":"","text":"Spring-Boot启动的时候会打印出spring官方的图案: 自定义这个图案方法如下:在/src/main/resources/新建一个banner.txt文件 登陆:http://patorjk.com/software/taag 将框中Type Something 替换成自己的单词字母,再将下面生成的图案复制到刚刚创建的那个txt中,再次启动项目,发现图案改变了","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"rabbitMQ死信队列","slug":"rabbitMQ死信队列","date":"2018-05-03T06:10:19.000Z","updated":"2018-05-25T09:38:50.240Z","comments":true,"path":"2018/05/03/rabbitMQ死信队列/","link":"","permalink":"https://shenyihan.github.io/2018/05/03/rabbitMQ死信队列/","excerpt":"","text":"应用场景：MQ队列信息消费失败后进入死信队列，实现延迟队列 介绍：DLX, Dead-Letter-Exchange。利用DLX, 当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。消息变成死信一向有一下几种情况： 消息被拒绝（basic.reject/ basic.nack）并且requeue=false 消息TTL过期（参考：RabbitMQ之TTL（Time-To-Live 过期时间）） 队列达到最大长度 DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性，当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列，可以监听这个队列中消息做相应的处理，这个特性可以弥补RabbitMQ 3.0以前支持的immediate参数（可以参考RabbitMQ之mandatory和immediate）的功能。 使用说明：@Bean public Queue fundConfirmQueue() { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //设置死信交换机 map.put(&quot;x-dead-letter-exchange&quot;, MessageQueueName.DLX_EXCHANGE); //设置死信routingKey map.put(&quot;x-dead-letter-routing-key&quot;, MessageQueueName.DLX_ROUTING_KEY); //消息被确认前的最大等待时间，默认为无限大 //arguments.put(&quot;x-message-ttl&quot;, 60000); //消息队列的最大大长度，默认永不过期 //arguments.put(&quot;x-max-length&quot;, 300); Queue queue = new Queue(MessageQueueName.fundConfirmQueue,true, false, false, map); return queue; } @Bean public Queue fundCancelQueue() { Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); //设置死信交换机 map.put(&quot;x-dead-letter-exchange&quot;, MessageQueueName.DLX_EXCHANGE); //设置死信routingKey map.put(&quot;x-dead-letter-routing-key&quot;, MessageQueueName.DLX_ROUTING_KEY); Queue queue = new Queue(MessageQueueName.fundCancelQueue,true, false, false, map); return queue; } /** * 死信交换机 */ @Bean public DirectExchange dlxExchange() { return new DirectExchange(MessageQueueName.DLX_EXCHANGE); } /** * 死信队列 */ @Bean public Queue dlxQueue() { return new Queue(MessageQueueName.DLX_QUEUE,true,false,false); } /** * 通过死信路由key绑定死信交换机和死信队列 */ @Bean public Binding dlxBinding() { return BindingBuilder.bind(dlxQueue()).to(dlxExchange()) .with(MessageQueueName.DLX_ROUTING_KEY); }","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"免费制作网站；","slug":"免费制作网站","date":"2018-04-28T05:47:54.000Z","updated":"2018-05-24T05:55:53.125Z","comments":true,"path":"2018/04/28/免费制作网站/","link":"","permalink":"https://shenyihan.github.io/2018/04/28/免费制作网站/","excerpt":"","text":"介绍旨在方便个人和企业快速搭建个人网站，本人利用业余时间在阿里云上搭建一套网站制作程序共享给大家。全部免费； 登录地址http://jujitouzi.com:8080/regByPhone.do?inviteid=392 使用步骤1、注册成功后发送将个人信息（姓名、电话、邮箱）发送至yuren_88@126.com；2、管理员审核通过后可登录进行修改自己的网站；3、需要域名的可以购买域名后直接绑定到预览页面即可； 问题各种问题及合作可以发送至yuren_88@126.com；","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"关于wluck开源说明","slug":"关于wluck开源说明","date":"2018-04-24T05:43:24.000Z","updated":"2018-05-25T09:39:08.838Z","comments":true,"path":"2018/04/24/关于wluck开源说明/","link":"","permalink":"https://shenyihan.github.io/2018/04/24/关于wluck开源说明/","excerpt":"","text":"wluck介绍wluck寓意为we luck，希望带给每一位使用者好运，当然还有框架的提供者们以及开源社区的朋友们。wluck是使用springboot开发的一款后台管理基础系统，拿来即用。 功能管理后台功能包含：用户管理、角色管理、权限管理、部门管理、菜单管理、字典管理、登录日志、操作日志、durid监控、通知管理等基础模块 技术架构采用springboot模块化开发、maven项目管理。整合架构：springboot+shiro+beetl+MyBatisplus+durid。 项目地址https://github.com/shenyihan/wluck 部署步骤1、下载源码至idea。2、使用项目中sql文件新建数据库并增加基础数据，修改Application.properties配置文件中数据库用户和密码。3、直接运行WLuckMgrApplication.main()方法即可。4、输入http://localhost:8090/ 用户名密码admin/111111。 讨论欢迎各位将使用中的问题反馈至yuren_88@126.com。 声明此项目借鉴开源项目及架构开发，作为本人学习与使用。","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"形态研究记录","slug":"形态研究记录","date":"2018-04-14T07:37:29.000Z","updated":"2018-04-14T07:37:29.526Z","comments":true,"path":"2018/04/14/形态研究记录/","link":"","permalink":"https://shenyihan.github.io/2018/04/14/形态研究记录/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mybatis-plus应用","slug":"mybatis-plus应用","date":"2018-04-10T05:51:10.000Z","updated":"2018-04-10T07:08:18.057Z","comments":true,"path":"2018/04/10/mybatis-plus应用/","link":"","permalink":"https://shenyihan.github.io/2018/04/10/mybatis-plus应用/","excerpt":"","text":"官方学习文档：http://baomidou.oschina.io/mybatis-plus-doc/#/?id=%e7%ae%80%e4%bb%8b 配置：&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;2.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatisplus-spring-boot-starter --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatisplus-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0.5&lt;/version&gt; &lt;/dependency&gt; 使用方式：1、通过实现baseMapper的**mapper调用数据操作方法，例如userMapper.insert(user); 2、ActiveRecord 方式 实现model类，通过实例类来操作，例如user.insert(); 实例：https://github.com/shenyihan/MyBatisPlusLearn","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"自律","slug":"自律","date":"2018-04-06T09:07:41.000Z","updated":"2018-05-25T09:39:28.631Z","comments":true,"path":"2018/04/06/自律/","link":"","permalink":"https://shenyihan.github.io/2018/04/06/自律/","excerpt":"","text":"首先转下在网上看到的关于自律的两句话。 王小波说，人一切的痛苦，本质上是对自己无能的愤怒。而自律，恰恰是解决人生痛苦的根本途径。比如拿运动来说，坚持运动的理由可能只有一个，但是放弃运动借口却有千千万。而对于高度自律的人，从来都不会给自己找任何借口。 只有自律的人，才能够真正掌控自己的人生，要知道一个人要管理好自己的行为和时间，往往并不需要很大外在的依赖和干预，更多的是克服自我的惰性并长期坚持养成各种好习惯。人往往都不能随心所欲，更多的是要做到严格约束自我行为，并逐渐变成有规律的好习惯，只有这样你才能获得更大的自由。 自律的第一点要慎独，一个人的自律不是给外面的人看的，更加不是为了晒朋友圈用的，而是自己对自己的严格要求，包括自我品格和道德意识的体现。正因为如此，我们更加应该关注在没人的时候，在别人看不见的时候做到严格要求和自我约束。一个高度自律的人往往有时候是孤独的，不需要太多的掌声，只需要听从你自己内心的声音，学会独处并孤芳自赏。 自律的第二点是接纳自己，不要去抱怨，不要去羡慕他人，不要去愤世嫉俗，更加不要怨天尤人，要勇于接纳现在的自己，包括自己所有的不完美。接纳自己本身也是个人成熟的表现，只有认识到自己的不足，从空虚和麻木中走出来，去努力寻求改变并付诸于自我实际行动。 自律的第三点是计划和目标，首先你要有目标，有了目标后制定详细的行动计划，然后就是严格的坚持和自律，并按照行动计划执行，在这个过程中不要给自己找任何借口，不要懈怠和放弃，坚持下来逐步形成自我的习惯和潜意识的行为和约束机制，那么你就是一个高度自律的人。","categories":[{"name":"生活","slug":"生活","permalink":"https://shenyihan.github.io/categories/生活/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://shenyihan.github.io/tags/感悟/"}]},{"title":"Docker 的常用操作命令和 Tomcat 的安装","slug":"Docker-的常用操作命令和-Tomcat-的安装","date":"2018-03-26T09:21:53.000Z","updated":"2018-05-25T09:38:29.463Z","comments":true,"path":"2018/03/26/Docker-的常用操作命令和-Tomcat-的安装/","link":"","permalink":"https://shenyihan.github.io/2018/03/26/Docker-的常用操作命令和-Tomcat-的安装/","excerpt":"","text":"[TOC] Docker 的常用操作命令和 Tomcat 的安装我们在安装完 Docker 后，肯定想第一时间安装对应的应用。那么该如何在 Docker 容器中安装应用呢？如何启动和访问 Docker 的所有命令，都可以在 Docker-hub 上找到对应资料，https://hub.docker.com/。 Docker 的 4 个主要的镜像操作命令。操作 命令 说明检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest列表 docker images 查看所有本地镜像删除 docker rmi image-id 删除指定的本地镜像靠上面 4 个主要的命令，我们基本上就可以做到得心应手。下面我以操作 Tomcat 为例，在详细的介绍一下 Docker 对应用的安装，启动，卸载，端口映射等教程。 Docker 的容器操作Docker 的软件镜像（就像QQ安装程序一样）需要通过运行镜像，然后产生一个容器（正在运行的软件，运行的QQ）；最后我们就可以使用这个容器了（使用QQ）。下面我们以 Tomcat 为例说说 Docker 的容器操作相关的命令。 在运行软件镜像之前，我们先需要搜索一下，这个镜像的版本等信息。相关搜索镜像命令如下： [root@localhost ~]# docker search tomcat搜索到对应的镜像后，我们就可以拉取镜像了。 [root@localhost ~]# docker pull tomcat拉去到镜像后，就可以根据镜像启动容器了。 docker run –name mytomcat -d tomcat:latest再接下来，我们就可以使用 docker ps 命令查看运行中的容器。 [root@localhost ~]# docker psdocker ps -a 命令是查看所有的容器，包括运行的和非运行的。 停止运行中的容器，可以使用 docker stop 命令。 docker stop 容器的id查看所有的容器 docker ps -a启动容器 docker start 容器id删除一个容器 docker rm 容器id启动一个做了端口映射的tomcat [root@localhost ~]# docker run -d -p 8888:8080 tomcat参数说明：-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 关闭 linux 防火墙命令： service firewalld status #查看防火墙状态service firewalld stop #关闭防火墙查看容器的日志 docker logs container-name/container-id","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"Docker安装","slug":"Docker安装","date":"2018-03-25T08:58:01.000Z","updated":"2018-05-25T09:04:32.709Z","comments":true,"path":"2018/03/25/Docker安装/","link":"","permalink":"https://shenyihan.github.io/2018/03/25/Docker安装/","excerpt":"","text":"[TOC] 在 linux 虚拟机上安装 docker第一步，检查 Linux 系统的内核版本，Docker 需要的内核必须是 3.10 及以上。检查内核版本的命令如下：uname -r 第二步，如果 Linux 版本是 3.10 以上，那么我们就可以进行安装 docker 了。安装 Docker 的命令如下：yum install docker安装过程中，提示输入 y/n 我们输入 y 进行确认安装。 第三步，在安装完成后，我们就可以正在的操作 Docker 了。下面是启动 docker 的命令：[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.6启动完成后，我们可以使用 docker -v 命令查看安装的 Docker 的版本信息。 第四步，设置 Docker 开机自启动。相关命令如下：[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 最后，我们再说说如何停止 docker。只需使用 systemctl stop docker 即可停止 Docker。systemctl stop docker","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"mycat学习使用","slug":"mycat学习使用","date":"2018-03-02T07:17:44.000Z","updated":"2018-03-29T06:25:46.525Z","comments":true,"path":"2018/03/02/mycat学习使用/","link":"","permalink":"https://shenyihan.github.io/2018/03/02/mycat学习使用/","excerpt":"","text":"安装 Mycat官网：http://www.mycat.io/可以了解下Mycat的背景和应用情况，这样使用起来比较有信心。 Mycat下载地址：http://dl.mycat.io/官网有个文档，属于详细的介绍，初次入门，看起来比较花时间。 下载：建议大家选择 1.6-RELEASE 版本，毕竟是比较稳定的版本。 安装：根据不同的系统选择不同的版本。包括linux、windows、mac,作者考虑还是非常周全的，当然，也有源码版的。（ps:源码版的下载后，只要配置正确，就可以正常运行调试，这个赞一下。） Mycat的安装其实只要解压下载的目录就可以了，非常简单。安装完成后，目录如下： 目录 说明bin mycat命令，启动、重启、停止等catlet catlet为Mycat的一个扩展功能conf Mycat 配置信息,重点关注lib Mycat引用的jar包，Mycat是java开发的logs 日志文件，包括Mycat启动的日志和运行的日志。配置 Mycat的配置文件都在conf目录里面，这里介绍几个常用的文件： 文件 说明server.xml Mycat的配置文件，设置账号、参数等schema.xml Mycat对应的物理数据库和数据库表的配置rule.xml Mycat分片（分库分表）规则Mycat的架构其实很好理解，Mycat是代理，Mycat后面就是物理数据库。和Web服务器的Nginx类似。对于使用者来说，访问的都是Mycat，不会接触到后端的数据库。我们现在做一个主从、读写分离，简单分表的示例。结构如下图： 服务器 IP 说明Mycat 192.168.0.2 mycat服务器，连接数据库时，连接此服务器database1 192.168.0.3 物理数据库1，真正存储数据的数据库database2 192.168.0.4 物理数据库2，真正存储数据的数据库Mycat作为主数据库中间件，肯定是与代码弱关联的，所以代码是不用修改的，使用Mycat后，连接数据库是不变的，默认端口是8066。连接方式和普通数据库一样，如：jdbc:mysql://192.168.0.2:8066/ server.xml 示例 test lunch false &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt; &lt;/user&gt; 重点关注下面这段，其他默认即可。 参数 说明user 用户配置节点–name 登录的用户名，也就是连接Mycat的用户名–password 登录的密码，也就是连接Mycat的密码–schemas 数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,dbs–privileges 配置用户针对表的增删改查的权限，具体见文档吧我这里配置了一个账号test 密码也是test,针对数据库lunch,读写权限都有，没有针对表做任何特殊的权限。 schema.xmlschema.xml是最主要的配置项，首先看我的配置文件。 &lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE mycat:schema SYSTEM “schema.dtd”&gt; &lt;schema name=&quot;lunch&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;lunchmenu&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;restaurant&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;userlunch&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;users&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;dictionary&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;mod-long&quot; /&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;test1&quot; database=&quot;lunch&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;test2&quot; database=&quot;lunch&quot; /&gt; &lt;dataHost name=&quot;test1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user();&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.0.2:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name=&quot;test2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user();&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostS1&quot; url=&quot;192.168.0.3:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; 参数 说明schema 数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应dataNode 分片信息，也就是分库相关配置dataHost 物理数据库，真正存储数据的数据库每个节点的属性逐一说明： schema: 属性 说明name 逻辑数据库名，与server.xml中的schema对应checkSQLschema 数据库前缀相关设置，建议看文档，这里暂时设为folsesqlMaxLimit select 时默认的limit，避免查询全表table: 属性 说明name 表名，物理数据库中表名dataNode 表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的nameprimaryKey 主键字段名，自动生成主键时需要设置autoIncrement 是否自增rule 分片规则名，具体规则下文rule详细介绍dataNode 属性 说明name 节点名，与table中dataNode对应datahost 物理数据库名，与datahost中name对应database 物理数据库中数据库名dataHost 属性 说明name 物理数据库名，与dataNode中dataHost对应balance 均衡负载的方式writeType 写入方式dbType 数据库类型heartbeat 心跳检测语句，注意语句结尾的分号要加。应用场景 数据库分表分库 配置如下： &lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE mycat:schema SYSTEM “schema.dtd”&gt; &lt;schema name=&quot;lunch&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;lunchmenu&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;restaurant&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;userlunch&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;users&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;dictionary&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;mod-long&quot; /&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;test1&quot; database=&quot;lunch&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;test2&quot; database=&quot;lunch&quot; /&gt; &lt;dataHost name=&quot;test1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user();&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.0.2:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;dataHost name=&quot;test2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user();&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostS1&quot; url=&quot;192.168.0.3:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; 我在192.168.0.2、192.168.0.3均有数据库lunch。lunchmenu、restaurant、userlunch、users这些表都只写入节点dn1，也就是192.168.0.2这个服务，而dictionary写入了dn1、dn2两个节点，也就是192.168.0.2、192.168.0.3这两台服务器。分片的规则为：mod-long。主要关注rule属性，rule属性的内容来源于rule.xml这个文件，Mycat支持10种分表分库的规则，基本能满足你所需要的要求，这个必须赞一个，其他数据库中间件好像都没有这么多。table中的rule属性对应的就是rule.xml文件中tableRule的name,具体有哪些分表和分库的实现，建议还是看下文档。我这里选择的mod-long就是将数据平均拆分。因为我后端是两台物理库，所以rule.xml中mod-long对应的function count为2，见下面部分代码： id mod-long 2 数据库读写分离 配置如下： &lt;?xml version=”1.0”?&gt;&lt;!DOCTYPE mycat:schema SYSTEM “schema.dtd”&gt; &lt;schema name=&quot;lunch&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;lunchmenu&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;restaurant&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;userlunch&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;users&quot; dataNode=&quot;dn1&quot; /&gt; &lt;table name=&quot;dictionary&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn1&quot; /&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;test1&quot; database=&quot;lunch&quot; /&gt; &lt;dataHost name=&quot;test1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&gt; &lt;heartbeat&gt;select user();&lt;/heartbeat&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.0.2:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;readHost host=&quot;hostM1&quot; url=&quot;192.168.0.3:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/readHost&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; 这样的配置与前一个示例配置改动如下：删除了table分配的规则,以及datanode只有一个datahost也只有一台，但是writehost总添加了readhost,balance改为1，表示读写分离。以上配置达到的效果就是102.168.0.2为主库，192.168.0.3为从库。 注意：Mycat主从分离只是在读的时候做了处理，写入数据的时候，只会写入到writehost，需要通过mycat的主从复制将数据复制到readhost，这个问题当时候我纠结了好久，数据写入writehost后，readhost一直没有数据，以为是自己配置的问题，后面才发现Mycat就没有实现主从复制的功能，毕竟数据库本身自带的这个功能才是最高效稳定的。 至于其他的场景，如同时主从和分表分库也是支持的了，只要了解这个实现以后再去修改配置，都是可以实现的。而热备及故障专业官方推荐使用haproxy配合一起使用，大家可以试试。使用 Mycat的启动也很简单，启动命令在Bin目录： ##启动mycat start ##停止mycat stop ##重启mycat restart如果在启动时发现异常，在logs目录中查看日志。 wrapper.log 为程序启动的日志，启动时的问题看这个mycat.log 为脚本执行时的日志，SQL脚本执行报错后的具体错误内容,查看这个文件。mycat.log是最新的错误日志，历史日志会根据时间生成目录保存。mycat启动后，执行命令不成功，可能实际上配置有错误，导致后面的命令没有很好的执行。 Mycat带来的最大好处就是使用是完全不用修改原有代码的，在mycat通过命令启动后，你只需要将数据库连接切换到Mycat的地址就可以了。如下面就可以进行连接了： mysql -h192.168.0.1 -P8806 -uroot -p123456连接成功后可以执行sql脚本了。所以，可以直接通过sql管理工具（如：navicat、datagrip）连接，执行脚本。我一直用datagrip来进行日常简单的管理，这个很方便。 Mycat还有一个管理的连接，端口号是9906. mysql -h192.168.0.1 -P9906 -uroot -p123456连接后可以根据管理命令查看Mycat的运行情况，当然，喜欢UI管理方式的人，可以安装一个Mycat-Web来进行管理，有兴趣自行搜索。 简而言之，开发中使用Mycat和直接使用Mysql机会没有差别。 常见问题 使用Mycat后总会遇到一些坑，我将自己遇到的一些问题在这里列一下，希望能与大家有共鸣： Mycat是不是配置以后，就能完全解决分表分库和读写分离问题？Mycat配合数据库本身的复制功能，可以解决读写分离的问题，但是针对分表分库的问题，不是完美的解决。或者说，至今为止，业界没有完美的解决方案。分表分库写入能完美解决，但是，不能完美解决主要是联表查询的问题，Mycat支持两个表联表的查询，多余两个表的查询不支持。 其实，很多数据库中间件关于分表分库后查询的问题，都是需要自己实现的，而且节本都不支持联表查询，Mycat已经算做地非常先进了。分表分库的后联表查询问题，大家通过合理数据库设计来避免。 Mycat支持哪些数据库，其他平台如 .net、PHP能用吗？官方说了，支持的数据库包括MySQL、SQL Server、Oracle、DB2、PostgreSQL 等主流数据库，很赞。尽量用Mysql,我试过SQL Server，会有些小问题，因为部分语法有点差异。 Mycat 非JAVA平台如 .net、PHP能用吗？可以用。这一点MyCat做的也很棒。 参考 《Mycat权威指南》： http://www.mycat.io/document/Mycat_V1.6.0.pdf官网 ：http://www.mycat.io/","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/tags/软件/"}]},{"title":"2018读书","slug":"2018读书","date":"2018-02-02T07:17:44.000Z","updated":"2018-02-02T07:18:43.428Z","comments":true,"path":"2018/02/02/2018读书/","link":"","permalink":"https://shenyihan.github.io/2018/02/02/2018读书/","excerpt":"","text":"金字塔原理","categories":[{"name":"读书","slug":"读书","permalink":"https://shenyihan.github.io/categories/读书/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://shenyihan.github.io/tags/读书/"}]},{"title":"微信机器人","slug":"微信机器人","date":"2018-01-15T07:51:40.000Z","updated":"2018-01-23T03:03:27.052Z","comments":true,"path":"2018/01/15/微信机器人/","link":"","permalink":"https://shenyihan.github.io/2018/01/15/微信机器人/","excerpt":"","text":"最近在做的项目，需要申请一些微信号进行营销工作，人工做费时费力。恰巧发现了wxpy可以实现让微信自动接收、处理消息然后进行回复的一系列功能。 现总结记录如下： 安装python，需要版本3以上yum install epel-release yum install python34 安装pipyum install python34-setuptools easy_install-3.4 pip 安装wxpypip3 install -i https://pypi.doubanio.com/simple/ -U wxpy 使用python3，pycharm根据wxpy官网操作即可。","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"微信","slug":"微信","permalink":"https://shenyihan.github.io/tags/微信/"}]},{"title":"波浪理论","slug":"波浪理论","date":"2018-01-10T06:08:48.000Z","updated":"2018-01-11T06:27:27.138Z","comments":true,"path":"2018/01/10/波浪理论/","link":"","permalink":"https://shenyihan.github.io/2018/01/10/波浪理论/","excerpt":"","text":"一、记录学习地址： http://www.360doc.com/content/11/1106/09/5096590_162169092.shtml二、记录缠论中枢理解：","categories":[{"name":"金融","slug":"金融","permalink":"https://shenyihan.github.io/categories/金融/"}],"tags":[{"name":"理论","slug":"理论","permalink":"https://shenyihan.github.io/tags/理论/"}]},{"title":"理论剖析","slug":"理论剖析","date":"2018-01-01T01:56:16.000Z","updated":"2018-02-27T02:10:38.060Z","comments":true,"path":"2018/01/01/理论剖析/","link":"","permalink":"https://shenyihan.github.io/2018/01/01/理论剖析/","excerpt":"","text":"总结一些著名理论的适用场景 江恩理论关注两种时间周期：对等周期和对等循环周期对等周期：下跌和上涨时间（所用交易日）相同 对等循环周期：选定一组高低点，在这组高低点的区间内又有很多的高低点，区间内第一个高低点距离区间左临界位交易日个数为8T，则区间右临界位+8即为变盘点（顶或底）； 龙虎榜的重要性例如说佛山普澜二路证券营业部","categories":[{"name":"金融","slug":"金融","permalink":"https://shenyihan.github.io/categories/金融/"}],"tags":[{"name":"股票操作","slug":"股票操作","permalink":"https://shenyihan.github.io/tags/股票操作/"}]},{"title":"短线操作","slug":"短线操作","date":"2018-01-01T01:56:16.000Z","updated":"2018-02-01T08:44:27.575Z","comments":true,"path":"2018/01/01/短线操作/","link":"","permalink":"https://shenyihan.github.io/2018/01/01/短线操作/","excerpt":"","text":"此篇博文用于记录本人2018所有短线操作，操作标的选取采用自创数据指标加通达信软件预警提示。 暂称这个指标为涨峰回吐，根据股票历史数据回测年化收益率能达到50%，有成功当然也会有失败，探索阶段，努力试错。 20180111，买入：002208合肥城建 成交价：10:30， 20180112，卖出-----------------------：10.69. 盈利585 20180115，买入：002131利欧股份 成交价：2.81， 20180115，买入：300465高伟达 成交价：9.96， 20180116，卖出：300465高伟达 成交价：10.27，盈利437 20180122, 卖出：002131利欧股份 成交价：2.74，亏损521 20180124，买入：600992贵绳股份 成交价：11.45， 20180125，卖出：600992贵绳股份 成交价：11.55，盈利120 20180131，买入：002109兴化股份 成交价：7.24， 20180131，买入：002106莱宝高科 成交价：9.81， 20180201，卖出：002109兴化股份 成交价：7.50。盈利493 仅供参考，据此操作盈亏自负。","categories":[{"name":"金融","slug":"金融","permalink":"https://shenyihan.github.io/categories/金融/"}],"tags":[{"name":"股票操作","slug":"股票操作","permalink":"https://shenyihan.github.io/tags/股票操作/"}]},{"title":"zookeeper安装使用","slug":"PageName","date":"2017-12-30T05:38:58.000Z","updated":"2018-01-23T03:05:01.783Z","comments":true,"path":"2017/12/30/PageName/","link":"","permalink":"https://shenyihan.github.io/2017/12/30/PageName/","excerpt":"","text":"Zookeeper是一个协调服务，可以用它来作为配置维护、名字服务、分布式部署；下面，我来分享一下在Linux下安装Zookeeper的整个步骤，让大家少走弯路。 Zookeeper下载wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.9/zookeeper-3.4.9.tar.gz [plain] view plain copy print? [root@localhost 下载]# wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz --2016-01-15 23:15:57-- http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.3.6/zookeeper-3.3.6.tar.gz 正在解析主机 mirror.bit.edu.cn (mirror.bit.edu.cn)... 114.247.56.117 正在连接 mirror.bit.edu.cn (mirror.bit.edu.cn)|114.247.56.117|:80... 已连接。 已发出 HTTP 请求，正在等待回应... 200 OK 长度：11833706 (11M) [application/octet-stream] 正在保存至: “zookeeper-3.3.6.tar.gz” 100%[======================================================================================================================================================================================&gt;] 11,833,706 171KB/s 用时 68s 2016-01-15 23:17:07 (170 KB/s) - 已保存 “zookeeper-3.3.6.tar.gz” [11833706/11833706]) 解压tar -zxvf /home/mgr/zookeeper-3.4.9.tar.gz [html] view plain copy print? [root@localhost deploy]# tar -zxvf /home/lk/下载/zookeeper-3.3.6.tar.gz 解压完之后，会在deploy文件夹下面得到一个zookeeper-3.3.6的文件夹 进入到conf目录[plain] view plain copy print? [root@localhost deploy]# cd /opt/deploy/zookeeper-3.3.6/conf 拷贝zoo_samle.cfg为zoo.cfg[plain] view plain copy print? [root@localhost conf]# cp zoo_sample.cfg zoo.cfg 编辑zoo.cfg文件[plain] view plain copy print? [root@localhost conf]# vi zoo.cfg 修改为： [html] view plain copy print? # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. dataDir=/usr/zookeeper dataLogDir=/usr/zookeeper/log # the port at which the clients will connect clientPort=2181 server.1=192.168.32.129:2888:3888 设置环境变量export ZOOKEEPER_INSTALL=/home/mgr/zookeeper-3.4.9 export PATH=$PATH:$ZOOKEEPER_INSTALL/bin [plain] view plain copy print? [root@localhost conf]# export ZOOKEEPER_INSTALL=/opt/deploy/zookeeper-3.3.6 [root@localhost conf]# export PATH=$PATH:$ZOOKEEPER_INSTALL/bin 启动[plain] view plain copy print? [root@localhost bin]# ./zkServer.sh start JMX enabled by default Using config: /opt/deploy/zookeeper-3.3.6/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@localhost bin]# 测试zookeeper[plain] view plain copy print? [root@localhost bin]# ./zkCli.sh -server 192.168.32.129:2181 如果是本地连接，那么不需要 -server 192.168.32.129:2181,默认是本地 注意：如果出现拒绝连接，请检查如下： 1、防火墙是否关闭 systemctl stop firewalld 2、需要将192.168.32.129 映射到本地 /etc/hosts文件中，否则无法连接 集群配置：在一个zookeeper集群中，只要半数以上的机器正常工作，整个集群即可处于正常工作的状态。 例如：3台机器组成的集群，只要int(3/2)+1=2台机器正常工作即可。也就是说允许3台中的1台机器宕机 1、设置vi /etc/hosts加 172.16.10.107 zookeeper-01 172.16.10.164 zookeeper-02 172.16.10.166 zookeeper-03 2、配置zoo.cfg 增加 dataDir=/home/mgr/zookeeper-3.4.9/data dataLogDir=/home/mgr/zookeeper-3.4.9/log server.1=zookeeper-01:2888:3888 server.2=zookeeper-02:2888:3888 server.3=zookeeper-03:2888:3888 3、在data下新建myid 内容分别为1/2/3 4、./zkServer.sh restart(重启)；./zkServer.sh status(查看状态)；./zkServer.sh stop(关闭)","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://shenyihan.github.io/tags/软件安装/"}]},{"title":"介绍资本公积金","slug":"my-new-post","date":"2017-12-29T03:38:16.000Z","updated":"2018-01-11T06:28:19.634Z","comments":true,"path":"2017/12/29/my-new-post/","link":"","permalink":"https://shenyihan.github.io/2017/12/29/my-new-post/","excerpt":"","text":"公积金就是从企业成立至今所获得的所有的利润中保留的一部分。要理解资本公积金，必须结合 净资产，股本，未分配利润等 项目结合理解。净资产=股本+资本公积金+未分配利润举例来说：公司1990年成立 股本是1千万。公司的净资产也是1千万。一开始啥也没有，公积金就是零，未分配利润也是零。 5年后，90-95年公司总共获利2千万，净资产就变成了3千万。按照国家规定，利润的10%必须转成资本公积金。所以：股本还是1千万，公积金就是2百万，未分配利润就是1千8百万。总计净资产3千万。每股公积金要除以总股本，所以每股公积金=0.2元。每股未分配利润1.8元，每股净资产3元。 95年，公司赚到了钱，应该给股东发红利了。根据公司法，股东只能分未分配利润，而股本和公积金是不能挪用的。因此公司最多派发1千8百万红利。最终决定向股东派发2百万红利。分红之后：股本还是1千万，公积金2百万，未分配利润变成1千6百万，净资产变成2千8百万。 96年，公司上市，公司每股净资产是2.8元，那么发行价10元应该没问题。发行了6百万股新股，募集了6千万资金。而发行面值1元的股票，售价10元，多出的9元就会计入公积金。也就是多了5千4百万的公积金。IPO后：股本1千6百万，公积金提高到5千6百万，未分配利润没变1千6百万，净资产8千8百万。每股公积金：3.5元，每股未分配利润：1元，每股净资产：5.5元。 97年，公司开始玩送转游戏。 新股上市，在高增长，高送转的预期下，股价到达20元。公司决定：10转10. 啥意思？ 就是每10股股票通过公积金转增股本10股。总体数据：原来是这样的（单位百万元）： 股本16 ， 公积金56， 未分配利润16， 净资产88转增之后变成这样： 股本32， 公积金40， 未分配利润16， 净资产88每股数据：原来是这样的： 每股公积金：3.5元 每股未分配利润：1元 每股净资产：5.5元转增之后变成这样： 每股公积金：1.25元 每股未分配利润：0.5元 每股净资产：2.75元 除权后股价从20元变成10元，每10股变成20股。 每股公积金大幅降低，每股净资产减半。 综上所述，公积金是个什么玩意？公积金就是净资产的一个部分，净资产的增加必须靠利润或者发行新股，公积金的值其实就是历年积累的利润×10%加上新股发行溢价。公积金不能动，所以和股本差不多，可以转成股本。 每股公积金高意味着公司有高送转的潜力，送转对公司未来发展没有影响，对股东也没有派发红利，只是在财务上调整了一下数据。","categories":[{"name":"金融","slug":"金融","permalink":"https://shenyihan.github.io/categories/金融/"}],"tags":[{"name":"金融知识点","slug":"金融知识点","permalink":"https://shenyihan.github.io/tags/金融知识点/"}]},{"title":"hexo加密实例","slug":"hexo加密实例","date":"2017-12-28T09:58:18.000Z","updated":"2018-01-12T10:15:48.897Z","comments":true,"path":"2017/12/28/hexo加密实例/","link":"","permalink":"https://shenyihan.github.io/2017/12/28/hexo加密实例/","excerpt":"","text":"================================================ ================================================ 恭喜你，测试成功。去给自己的博客设置一道屏障吧。 ================================================ ================================================","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shenyihan.github.io/tags/博客搭建/"}]},{"title":"hexo设置加密博文","slug":"hexo设置加密博文","date":"2017-12-28T09:45:55.000Z","updated":"2018-01-12T10:36:39.297Z","comments":true,"path":"2017/12/28/hexo设置加密博文/","link":"","permalink":"https://shenyihan.github.io/2017/12/28/hexo设置加密博文/","excerpt":"","text":"最近写了一篇个人文章，想设置成密码登录后才能观看。网上也试了一些其他人的方案，但基本都不能用 现就修改流程总结如下： 一、目 的：对某一篇文章输入密码后才能观看。 二、修改内容：1、增加js前端控制功能 mythemes\\layout\\_partial\\head.ejs 增加如下代码 &lt;% var password = page.password; if(password) { %&gt; &lt;script&gt; (function(){ if (prompt(&apos;请输入文章密码&apos;) != &quot;&lt;%= password %&gt;&quot;){ alert(&apos;密码错误！&apos;); history.back(); } })(); &lt;/script&gt; &lt;%}%&gt; 2、将需要设置加密模式观看的md文章抬头增加 password: 你的密码；类似于tags标签。 三、实 例： 链接：https://shenyihan.github.io/2017/12/28/hexo加密实例/ 密码：password","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shenyihan.github.io/tags/博客搭建/"}]},{"title":"hexo从零开始到搭建完整","slug":"hello-world","date":"2017-12-27T03:38:16.000Z","updated":"2018-01-13T03:21:42.614Z","comments":true,"path":"2017/12/27/hello-world/","link":"","permalink":"https://shenyihan.github.io/2017/12/27/hello-world/","excerpt":"","text":"安装Git Bash安装NodeJs安装hexo生成SSH并添加到github部署项目上传到github绑定个人域名修改及配置主题添加RSS添加评论增加\\mythemes\\layout_partial\\plugins\\laibili.ejs &lt;% if (theme.livere_uid){ %&gt; (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) { return; } j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); })(document, &apos;script&apos;); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;!-- City版安装代码已完成 --&gt; &lt;/section&gt; &lt;% } %&gt; comment.ejs增加&lt;%- partial(‘../plugins/laibili’) %&gt;_config.yml增加livere_uid:xxxx写文章部分","categories":[{"name":"软件","slug":"软件","permalink":"https://shenyihan.github.io/categories/软件/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://shenyihan.github.io/tags/博客搭建/"}]},{"title":"about","slug":"about","date":"2017-12-20T07:37:01.000Z","updated":"2018-01-16T08:08:31.264Z","comments":true,"path":"2017/12/20/about/","link":"","permalink":"https://shenyihan.github.io/2017/12/20/about/","excerpt":"","text":"全世界只有不到百万分之一的人访问我的博客，你真是个特别的人 关于我： name：杨向成 backgroud:攻城狮 关于博客： 扯淡、分享 联系我： mail：yuren_88@126.com","categories":[{"name":"关于我","slug":"关于我","permalink":"https://shenyihan.github.io/categories/关于我/"}],"tags":[{"name":"关于我","slug":"关于我","permalink":"https://shenyihan.github.io/tags/关于我/"}]}]}